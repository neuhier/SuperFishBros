import numpy as np
# import pandas as pd
# from sklearn.decomposition import PCA
from scipy.spatial.distance import cdist

""" # Import the pygame module
import pygame
import random

# Define constants for the screen width and height
SCREEN_WIDTH = 400
SCREEN_HEIGHT = 300

# Load Images and scale
PlayerImage =  pygame.image.load("imgs/players/redfish.png")
PlayerImage = pygame.transform.scale(PlayerImage, (64, 44))
SalatImage = pygame.image.load("imgs/objects/collectables/meersalat.png")
SalatImage = pygame.transform.scale(SalatImage, (40, 30))

# Define a Player object by extending pygame.sprite.Sprite
# The surface drawn on the screen is now an attribute of 'player'
class Player(pygame.sprite.Sprite):
    def __init__(self):
        super(Player, self).__init__()
        self.surf = PlayerImage.convert()
        self.surf.set_colorkey((0,0,0))
        self.rect = self.surf.get_rect()
    # Move the sprite based on user keypresses
    def update(self, pressed_keys):
        if pressed_keys[K_UP]:
            self.rect.move_ip(0, -5)
        if pressed_keys[K_DOWN]:
            self.rect.move_ip(0, 5)
        if pressed_keys[K_LEFT]:
            self.rect.move_ip(-5, 0)
        if pressed_keys[K_RIGHT]:
            self.rect.move_ip(5, 0)
            # Keep player on the screen
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH
        if self.rect.top <= 0:
            self.rect.top = 0
        if self.rect.bottom >= SCREEN_HEIGHT:
            self.rect.bottom = SCREEN_HEIGHT

# Define the enemy object by extending pygame.sprite.Sprite
# The surface you draw on the screen is now an attribute of 'enemy'
class Enemy(pygame.sprite.Sprite):
    def __init__(self):
        super(Enemy, self).__init__()
        self.surf = SalatImage.convert()
        self.surf.set_colorkey((0,0,0))
        self.rect = self.surf.get_rect(
            center=(
                random.randint(SCREEN_WIDTH + 20, SCREEN_WIDTH + 100),
                random.randint(0, SCREEN_HEIGHT),
            )
        )
        self.speed = random.randint(1, 5)

    # Move the sprite based on speed
    # Remove the sprite when it passes the left edge of the screen
    def update(self):
        self.rect.move_ip(-self.speed, 0)
        if self.rect.right < 0:
            self.kill()

# Initialize pygame
pygame.init()

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

player = Player()

enemies = pygame.sprite.Group()

for i in range(4):
    new_enemy = Enemy()
    enemies.add(new_enemy)

for i in enemies:
    i.rect.centerx = i.rect.centerx - 150

npcs = 10 """

# getState
# 
# Get the state of the game. This is defined by the 
# position and size of players and enemies. The state
# is generated by applying a pca on the "image" of
# the game state.
# 
# @param player The player object.
#
# @param enemies The sprite group of enemies
#
# @param npcs The number of principal components to return.
# 
# @param width, height Height and width of the screen.
#
""" def getState(player, enemnies, npcs, width, height):

    # Make the "game state image"
    game_state_image = np.zeros((height, width))

    # Add player/agent position 
    game_state_image[player.rect.centery+1][player.rect.centerx] = 1

    # Add enemies
    for i in enemies:
        if i.rect.centery+1 < height & i.rect.centery > 0 & i.rect.centerx + 1 < width & i.rect.center.x > 0:
            game_state_image[i.rect.centery+1][i.rect.centerx+1] = 2

    # Apply pca
    game_state_df = pd.DataFrame(game_state_image)

    pca_model = PCA(n_components=npcs)
    compressed = pca_model.fit_transform(game_state_df)
    return(compressed)

 """
# Get the position of the n nearest enemies
def getStateNearest(player, enemies, n):
            
    # Get the coordinates of all enemies
    e_coords = np.zeros((len(enemies), 2))
    for i, e in enumerate(enemies):
        e_coords[i][0] = e.rect.centerx
        e_coords[i][1] = e.rect.centery

    # Calculate distance to player for each enemy
    distances = cdist([(player.rect.centerx,player.rect.centery)], e_coords).ravel()

    # get the n smallest enemies
    if len(enemies) <= n:
        return np.pad(e_coords.flatten(), (1, n), "constant", constant_values=0) # Fill with 0 # TODO: Use NA instead
    else:
        indices = np.argpartition(distances, n)
        return e_coords[indices[:n]].flatten()